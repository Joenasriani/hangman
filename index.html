<!DOCTYPE html>
<html>
  <head>
    <title>3D WebXR Hangman</title>
    <meta name="description" content="3D WebXR Hangman game using A-Frame.">
    <!-- Import A-Frame Library --><script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <!-- Import A-Frame Environment Component --><script src="https://unpkg.com/aframe-environment-component@1.3.4/dist/aframe-environment-component.min.js"></script>
  </head>
  <body>
    <a-scene game-manager>
      
      <!-- 1. ASSETS & ENVIRONMENT --><a-assets>
        <!-- Sound effects --><audio id="click-sound" src="https://aframe.io/sample-assets/assets/audio/click.ogg"></audio>
        <audio id="win-sound" src="https://aframe.io/sample-assets/assets/audio/chime.mp3"></audio>
        <audio id="lose-sound" src="https://aframe.io/sample-assets/assets/audio/explosion.mp3"></audio>
      </a-assets>

      <!-- Colorful Environment --><a-entity 
        environment="preset: default; 
                     skyColor: #37b3f0; 
                     ground: flat; 
                     groundColor: #3d592a;
                     groundTexture: none;
                     fog: 0.1;"
      ></a-entity>
      
      <a-light type="ambient" color="#AAA"></a-light>
      <a-light type="point" intensity="0.5" position="2 4 4"></a-light>

      <!-- 2. PLAYER RIG --><!-- Adjusted initial position for a taller viewer (y=1.8 instead of 0) --><a-entity id="playerRig" position="0 1.8 2" camera-gestures>
        <a-camera>
          <!-- Cursor for mobile gaze-based clicking --><a-cursor 
            color="#FFF"
            raycaster="objects: .clickable"
            fuse="false"
          ></a-cursor>
        </a-camera>
        <!-- Controller with a laser pointer for VR --><a-entity 
          laser-controls="hand: right"
          raycaster="objects: .clickable"
        ></a-entity>
      </a-entity>

      <!-- 3. GAME UI --><!-- Word Display --><a-entity 
        id="word-display" 
        position="0 2.5 -3"
        visible="false" <!-- Hidden until game starts -->></a-entity>
      
      <!-- Status Message --><a-text
        id="status-message"
        value="Welcome to 3D Hangman!"
        align="center"
        width="6"
        position="0 3.1 -3"
        color="#FFF"
      ></a-text>
      
      <!-- 3D Start/Reset Button --><a-entity 
        id="start-reset-button-container" 
        position="0 1.8 -2.5"
      >
        <a-box
          id="start-reset-button"
          class="clickable"
          width="1.5"
          height="0.4"
          depth="0.1"
          color="#00796b"
          animation__hoveron="property: scale; to: 1.1 1.1 1.1; startEvents: mouseenter; dur: 200"
          animation__hoveroff="property: scale; to: 1 1 1; startEvents: mouseleave; dur: 200"
        >
          <a-text
            id="start-reset-button-text"
            value="START HANGMAN"
            align="center"
            width="3"
            position="0 0 0.06"
            color="#FFF"
          ></a-text>
        </a-box>
      </a-entity>
      
      <!-- Keyboard --><a-entity 
        id="keyboard" 
        position="0 1.4 -2.5"
        visible="false" <!-- Hidden until game starts -->></a-entity>
      
      <!-- 
        3D Hangman Structure 
        Positioned above the word display area
      --><a-entity id="hangman-structure" position="0 3.8 -3" scale="0.8 0.8 0.8">
        <a-box id="hm-base" position="0 0.1 0" width="2" height="0.2" depth="1" color="#634734" visible="false"></a-box>
        <a-cylinder id="hm-post" position="0.8 1.1 0" radius="0.1" height="2" color="#634734" visible="false"></a-cylinder>
        <a-box id="hm-beam" position="0.1 2.1 0" width="1.6" height="0.2" depth="0.2" color="#634734" visible="false"></a-box>
        <a-cylinder id="hm-rope" position="-0.6 1.8 0" radius="0.03" height="0.6" color="#D2B48C" visible="false"></a-cylinder>
        <a-sphere id="hm-head" position="-0.6 1.4 0" radius="0.15" color="#FFE4C4" visible="false"></a-sphere>
        <a-box id="hm-body" position="-0.6 1.0 0" width="0.1" height="0.6" depth="0.1" color="#C0392B" visible="false"></a-box>
      </a-entity>

      <!-- Sound components --><a-sound src="#click-sound" id="keyboardClickSound"></a-sound>
      <a-sound src="#win-sound" id="winGameSound"></a-sound>
      <a-sound src="#lose-sound" id="loseGameSound"></a-sound>

    </a-scene>

    <script>
    // Custom component for handling camera movement and zoom via gestures
    AFRAME.registerComponent('camera-gestures', {
        init: function () {
            this.cameraEl = this.el; // playerRig is the camera rig
            this.initialPos = this.cameraEl.object3D.position.clone();
            this.initialScale = this.cameraEl.object3D.scale.clone();
            this.isPinching = false;
            this.lastDistance = 0;
            this.lastMidpoint = new THREE.Vector2();
            this.isDragging = false;
            this.lastX = 0;
            this.lastY = 0;

            const sceneEl = this.el.sceneEl;
            sceneEl.addEventListener('touchstart', this.onTouchStart.bind(this));
            sceneEl.addEventListener('touchmove', this.onTouchMove.bind(this));
            sceneEl.addEventListener('touchend', this.onTouchEnd.bind(this));
        },

        onTouchStart: function (evt) {
            if (evt.touches.length === 2) {
                this.isPinching = true;
                this.lastDistance = this.getDistance(evt.touches);
                this.lastMidpoint = this.getMidpoint(evt.touches);
            } else if (evt.touches.length === 1) {
                this.isDragging = true;
                this.lastX = evt.touches[0].clientX;
                this.lastY = evt.touches[0].clientY;
            }
        },

        onTouchMove: function (evt) {
            if (this.isPinching && evt.touches.length === 2) {
                const currentDistance = this.getDistance(evt.touches);
                const distanceChange = currentDistance - this.lastDistance;
                this.lastDistance = currentDistance;

                // Zoom (move forward/backward along Z axis)
                const currentZ = this.cameraEl.object3D.position.z;
                this.cameraEl.object3D.position.z += distanceChange * 0.005; // Adjust sensitivity
                // Clamp zoom to reasonable limits (e.g., between -5 and 5)
                this.cameraEl.object3D.position.z = Math.max(-10, Math.min(5, this.cameraEl.object3D.position.z));
                
                const currentMidpoint = this.getMidpoint(evt.touches);
                const dx = currentMidpoint.x - this.lastMidpoint.x;
                const dy = currentMidpoint.y - this.lastMidpoint.y;
                this.lastMidpoint = currentMidpoint;

                // Pan (move along X and Y axis relative to camera direction)
                // Convert screen delta to world coordinates. This is a simplified approach.
                const moveSpeed = 0.002; // Adjust sensitivity
                const deltaX = -dx * moveSpeed;
                const deltaY = dy * moveSpeed;

                // Apply movement relative to the camera's current orientation
                let currentPos = this.cameraEl.object3D.position;
                let forward = new THREE.Vector3(0,0,-1).applyQuaternion(this.cameraEl.object3D.quaternion);
                let right = new THREE.Vector3(1,0,0).applyQuaternion(this.cameraEl.object3D.quaternion);
                let up = new THREE.Vector3(0,1,0).applyQuaternion(this.cameraEl.object3D.quaternion);

                this.cameraEl.object3D.position.addScaledVector(right, deltaX);
                this.cameraEl.object3D.position.addScaledVector(up, deltaY);


            } else if (this.isDragging && evt.touches.length === 1) {
                const currentX = evt.touches[0].clientX;
                const currentY = evt.touches[0].clientY;
                const dx = currentX - this.lastX;
                const dy = currentY - this.lastY;
                this.lastX = currentX;
                this.lastY = currentY;

                // Pan (move along X and Y axis relative to camera direction)
                const moveSpeed = 0.002; // Adjust sensitivity
                const deltaX = -dx * moveSpeed;
                const deltaY = dy * moveSpeed;
                
                let currentPos = this.cameraEl.object3D.position;
                let right = new THREE.Vector3(1,0,0).applyQuaternion(this.cameraEl.object3D.quaternion);
                let up = new THREE.Vector3(0,1,0).applyQuaternion(this.cameraEl.object3D.quaternion);

                this.cameraEl.object3D.position.addScaledVector(right, deltaX);
                this.cameraEl.object3D.position.addScaledVector(up, deltaY);
            }
        },

        onTouchEnd: function (evt) {
            this.isPinching = false;
            this.isDragging = false;
        },

        getDistance: function (touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        },

        getMidpoint: function (touches) {
            return new THREE.Vector2(
                (touches[0].clientX + touches[1].clientX) / 2,
                (touches[0].clientY + touches[1].clientY) / 2
            );
        }
    });

    // Global tap listener component to dispatch clicks to the currently gazed element
    AFRAME.registerComponent('global-tap-listener', {
      init: function () {
        const sceneEl = this.el.sceneEl;
        sceneEl.addEventListener('touchend', this.handleGlobalTap.bind(this));
      },

      handleGlobalTap: function () {
        const cursorEl = document.querySelector('a-cursor');
        if (!cursorEl) return;

        const intersectedEl = cursorEl.components.raycaster.intersectedEls[0];
        if (intersectedEl && intersectedEl.classList.contains('clickable')) {
          // Dispatch a click event to the intersected element
          // This will trigger the game-manager's click handler
          intersectedEl.click();
        }
      }
    });


    AFRAME.registerComponent('game-manager', {
      schema: {},

      init: function () {
        // --- Game State ---
        
        // Expanded word list
        this.wordList = [
          'WEBXR', 'AFRAME', 'HANGMAN', 'VIRTUAL', 'REALITY', 'JAVASCRIPT', 
          'METAVERSE', 'QUEST', 'CONTROLLER', 'HEADSET', 'IMMERSIVE', 'AUGMENTED', 
          'INTERNET', 'BROWSER', 'DEVELOPER', 'COMPONENT', 'ENTITY', 'SYSTEM', 
          'GITHUB', 'GLITCH', 'CODING', 'PROGRAM', 'CHROME', 'FIREFOX', 
          'MOBILE', 'DESKTOP', 'AVATAR', 'ENVIRONMENT', 'ANIMATION', 'TEXTURE', 
          'POLYGON', 'SHADER'
        ];
        
        this.secretWord = '';
        this.guessedLetters = [];
        this.incorrectGuesses = 0;
        
        // LOGIC: Max guesses is 6
        this.maxGuesses = 6; 
        this.gameActive = false;

        // --- A-Frame Entity References ---
        this.wordDisplayEl = document.getElementById('word-display');
        this.keyboardEl = document.getElementById('keyboard');
        this.statusMessageEl = document.getElementById('status-message');
        
        this.resetButtonContainerEl = document.getElementById('start-reset-button-container');
        this.resetButtonEl = document.getElementById('start-reset-button');
        this.resetButtonTextEl = document.getElementById('start-reset-button-text');
        
        // Get references to sound components
        this.keyboardClickSound = document.getElementById('keyboardClickSound');
        this.winGameSound = document.getElementById('winGameSound');
        this.loseGameSound = document.getElementById('loseGameSound');

        this.hangmanParts = [
          document.getElementById('hm-base'),
          document.getElementById('hm-post'),
          document.getElementById('hm-beam'),
          document.getElementById('hm-rope'),
          document.getElementById('hm-head'),
          document.getElementById('hm-body')
        ];

        // --- Initial Setup ---
        this.createKeyboard();
        this.hideHangman();
        
        this.statusMessageEl.setAttribute('value', 'Welcome to 3D Hangman!');
        this.keyboardEl.setAttribute('visible', 'false');
        this.wordDisplayEl.setAttribute('visible', 'false');
        this.resetButtonContainerEl.setAttribute('visible', 'true');
        this.resetButtonTextEl.setAttribute('value', 'START HANGMAN');
        
        // --- Event Listeners ---
        // Changed to listen for 'touchend' event for global tap functionality
        this.keyboardEl.addEventListener('click', this.handleKeyboardClick.bind(this));
        this.resetButtonEl.addEventListener('click', this.startGame.bind(this));

        // Attach global tap listener to the scene
        this.el.setAttribute('global-tap-listener', '');
      },

      startGame: function () {
        this.gameActive = true;
        this.guessedLetters = [];
        this.incorrectGuesses = 0;

        // Pick a random word
        this.secretWord = this.wordList[Math.floor(Math.random() * this.wordList.length)];
        
        // Reset UI
        this.statusMessageEl.setAttribute('value', 'Guess a letter!');
        this.resetButtonContainerEl.setAttribute('visible', 'false'); 
        this.keyboardEl.setAttribute('visible', 'true'); 
        this.wordDisplayEl.setAttribute('visible', 'true'); 
        
        this.resetKeyboard();
        this.hideHangman();
        this.createWordDisplay();
      },
      
      createWordDisplay: function () {
        // Clear previous word
        while (this.wordDisplayEl.firstChild) {
          this.wordDisplayEl.removeChild(this.wordDisplayEl.firstChild);
        }

        const wordLength = this.secretWord.length;
        // Adjusted spacing for letters to make the total word length shorter
        const letterSpacing = 0.4; // Reduced from 0.6
        const totalWidth = wordLength * letterSpacing; 
        const startX = -totalWidth / 2 + (letterSpacing / 2);

        for (let i = 0; i < wordLength; i++) {
          let letterEl = document.createElement('a-text');
          letterEl.setAttribute('value', '_');
          letterEl.setAttribute('align', 'center');
          letterEl.setAttribute('width', '4');
          letterEl.setAttribute('color', '#FFF');
          letterEl.setAttribute('position', { x: startX + i * letterSpacing, y: 0, z: 0 });
          this.wordDisplayEl.appendChild(letterEl);
        }
      },

      createKeyboard: function () {
        const rows = [
          'QWERTYUIOP',
          'ASDFGHJKL',
          'ZXCVBNM'
        ];
        
        let yPos = 0.5;

        rows.forEach((row, rowIndex) => {
          let rowLength = row.length;
          
          let keySpac = 0.4; // Spacing between key centers (matches word spacing now)
          let keySize = 0.35; // Visual size of key
          let xOffset = -(rowLength * keySpac) / 2 + (keySpac / 2); // Center the row
          
          for (let i = 0; i < row.length; i++) {
            let letter = row[i];
            
            let button = document.createElement('a-box');
            button.setAttribute('position', { x: xOffset + i * keySpac, y: yPos, z: 0 });
            button.setAttribute('width', keySize);
            button.setAttribute('height', keySize);
            button.setAttribute('depth', '0.1');
            button.setAttribute('color', '#1e88e5'); 
            button.setAttribute('class', 'clickable keyboard-button'); 
            button.setAttribute('data-letter', letter); 
            
            // Hover animations
            button.setAttribute('animation__hoveron', 'property: scale; to: 1.2 1.2 1.2; startEvents: mouseenter; dur: 150');
            button.setAttribute('animation__hoveroff', 'property: scale; to: 1 1 1; startEvents: mouseleave; dur: 150');
            // Click animation (color change)
            button.setAttribute('animation__clickcolor', 'property: components.material.material.color; type: color; to: #0d47a1; startEvents: mousedown; dur: 50');
            button.setAttribute('animation__clickrecolor', 'property: components.material.material.color; type: color; to: #1e88e5; startEvents: mouseup; dur: 150');
            
            let text = document.createElement('a-text');
            text.setAttribute('value', letter);
            text.setAttribute('align', 'center');
            text.setAttribute('width', '2');
            text.setAttribute('color', '#FFF');
            text.setAttribute('position', '0 0 0.06'); 
            
            button.appendChild(text);
            this.keyboardEl.appendChild(button);
          }
          yPos -= keySpac; 
        });
      },

      handleKeyboardClick: function (evt) {
        if (!this.gameActive) return;

        const buttonEl = evt.target;
        if (!buttonEl.classList.contains('keyboard-button')) return;
        
        const letter = buttonEl.getAttribute('data-letter');
        
        if (this.guessedLetters.includes(letter)) return;
        
        this.guessedLetters.push(letter);
        
        // Play click sound
        this.keyboardClickSound.components.sound.playSound();

        buttonEl.setAttribute('color', '#646464'); 
        buttonEl.removeAttribute('animation__hoveron');
        buttonEl.removeAttribute('animation__hoveroff');
        // Prevent re-triggering click animations on disabled buttons
        buttonEl.removeAttribute('animation__clickcolor');
        buttonEl.removeAttribute('animation__clickrecolor');

        this.processGuess(letter);
      },
      
      processGuess: function(letter) {
        let correctGuess = false;
        let wordComplete = true;

        const letterEls = this.wordDisplayEl.children;
        for (let i = 0; i < this.secretWord.length; i++) {
          if (this.secretWord[i] === letter) {
            letterEls[i].setAttribute('value', letter);
            correctGuess = true;
          }
          if (letterEls[i].getAttribute('value') === '_') {
            wordComplete = false;
          }
        }
        
        if (correctGuess) {
          this.statusMessageEl.setAttribute('value', 'Good Guess!');
          if (wordComplete) {
            this.endGame(true);
          }
        } else {
          this.incorrectGuesses++;
          this.statusMessageEl.setAttribute('value', `Incorrect! ${this.maxGuesses - this.incorrectGuesses} guesses left.`);
          this.updateHangman();
          
          if (this.incorrectGuesses >= this.maxGuesses) {
            this.endGame(false);
          }
        }
      },
      
      updateHangman: function() {
        if (this.incorrectGuesses > 0 && this.incorrectGuesses <= this.hangmanParts.length) {
          this.hangmanParts[this.incorrectGuesses - 1].setAttribute('visible', 'true');
        }
      },
      
      endGame: function(didWin) {
        this.gameActive = false;
        
        if (didWin) {
          this.statusMessageEl.setAttribute('value', 'YOU WIN!');
          this.winGameSound.components.sound.playSound(); // Play win sound
        } else {
          this.statusMessageEl.setAttribute('value', `YOU LOSE! Word was: ${this.secretWord}`);
          this.loseGameSound.components.sound.playSound(); // Play lose sound
          const letterEls = this.wordDisplayEl.children;
          for (let i = 0; i < this.secretWord.length; i++) {
             letterEls[i].setAttribute('value', this.secretWord[i]);
          }
        }
        
        this.keyboardEl.setAttribute('visible', 'false');
        this.resetButtonContainerEl.setAttribute('visible', 'true');
        this.resetButtonTextEl.setAttribute('value', 'Play Again?');
      },
      
      resetKeyboard: function() {
        let buttons = this.keyboardEl.querySelectorAll('.keyboard-button');
        buttons.forEach(button => {
          button.setAttribute('color', '#1e88e5'); 
          button.setAttribute('animation__hoveron', 'property: scale; to: 1.2 1.2 1.2; startEvents: mouseenter; dur: 150');
          button.setAttribute('animation__hoveroff', 'property: scale; to: 1 1 1; startEvents: mouseleave; dur: 150');
          // Re-add click animations
          button.setAttribute('animation__clickcolor', 'property: components.material.material.color; type: color; to: #0d47a1; startEvents: mousedown; dur: 50');
          button.setAttribute('animation__clickrecolor', 'property: components.material.material.color; type: color; to: #1e88e5; startEvents: mouseup; dur: 150');
        });
      },
      
      hideHangman: function() {
        this.hangmanParts.forEach(part => {
          part.setAttribute('visible', 'false');
        });
      }
    });
    </script>
  </body>
</html>
